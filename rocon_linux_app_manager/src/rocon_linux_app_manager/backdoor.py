'''
Handles invitations to join from a concert master.

@author: Daniel Stonier
'''
##############################################################################
# Imports
##############################################################################

import socket
import threading
#from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler 
from SimpleXMLRPCServer import SimpleXMLRPCServer 

# Ros Imports
import roslib; roslib.load_manifest('rocon_linux_app_manager')
import rospy

from zeroconf_msgs.msg import Protocols

# Local Imports
from .zeroconf_utils import ipv4_protocol
from .zeroconf_utils import discover_concerts
from .zeroconf_utils import listen_for_concerts

##############################################################################
# Classes
##############################################################################

class Backdoor(threading.Thread):
    '''
      Sets up an xmlrpc server to handle requests from a concert master to joint.
      This will usually get installed directly into the app managers.
      
      Important variables that should be visible to users of this class
      
      @var concert_master - zeroconf details for the concert master
      @var robot_namespace - namespace that apps must be launched under
      @var port - port that the xmrpc backdoor is running on
      
      @arg platform_info : contains the platform-system-robot triple, key and suggested_name
      @arg whitelist/blacklist : internally to help the backdoor decide whether to serve a specific concert master or not
      @arg receive_invitation_callback : used when the backdoor receives an invitation.
    '''
    def __init__(self, platform_info, whitelist, blacklist, receive_invitation_callback):
        threading.Thread.__init__(self)
        
        # Visible variables
        self.concert_master = None
        self.robot_namespace = None
        self.port = 0
        self._server = None

        self._unique_names = {} # pairs concert masters with unique names provided by the concert masters
        
        # System-Platform-Robot triple : first and second are fixed, third is variable (ros.linux.*)
        # Key : unique id generated by uuid
        # Suggested Name : this is the hint given to the concert from which the concert will generate a
        #                   unique name and pass back
        self.platform_info = platform_info

        # These allow for some decision logic when accepting invitations from concert masters
        self._whitelist = whitelist
        self._blacklist = blacklist
        
        # Private variables
        self._receive_invitation_callback = receive_invitation_callback

        # Get server details and an unused port
        self.hostname = roslib.network.get_host_name()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(("",0))  # The empty string is equivalent to socket.INADDR_ANY (any network interface on the computer)
        self.address,self.port = s.getsockname()
        s.close()
        # There is a small window here where someone else can grab the unused socket
        # so we should really put in checks below to make sure we don't get an error.
        
        # XmlRpc server setup
        self._server = SimpleXMLRPCServer(("", self.port)) # The empty hostname string is equivalent to socket.INADDR_ANY (any network interface on the computer)
        self._server.register_introspection_functions() # allows a client to do print s.system.listMethods()
        self._server.register_function(self.invite, 'invite')
        self._server.register_function(self.platform, 'platform')
        self._server.register_function(self.system, 'system')
        self._server.register_function(self.robot, 'robot')
        self._server.register_function(self.key, 'key')
        self._server.register_function(self.suggested_name, 'suggested_name')
        self._server.register_function(self.unique_name, 'unique_name')

        listen_for_concerts()
                
    def run(self): 
        self._server.serve_forever()
        
    def stop(self):
        '''
          Shutdown the xmlrpc server, also stop the zeroconf services.
        '''
        self._server.shutdown()
        if self.isAlive():
            self.join()
    
    ########################################################################
    # Backdoor XmlRpc Server Methods
    ########################################################################
    ############################
    # Platform Info
    ############################
    def system(self):
        return self.platform_info.system;
    def platform(self):
        return self.platform_info.platform;
    def robot(self):
        return self.platform_info.robot;
    def key(self):
        return self.platform_info.key;
    def suggested_name(self):
        return self.platform_info.suggested_name;

    def unique_name(self, concert_name, robot_namespace):
        '''
           Lets the app manager store a unique name to use (at some point in the future) 
           with the corresponding concert master.
            
           @param concert_name : the zeroconf name for the concert master (have to resolve ip, port against this)
           @param robot_namespace : the namespace to expose to the concert (must be unique!)
        '''
        self._unique_names[concert_name] = robot_namespace
        return True
        
    def invite(self, concert_name):
        '''
           Server's callback function for handling invitation requests.
           @param concert_name : the zeroconf name for the concert master (have to resolve ip, port against this)
        '''
        ######################
        # Whitelist/Blacklist
        ######################
        rospy.loginfo("App Manager: received an invitation from '%s'."%concert_name)
        if self._whitelist: # wwhitelists have priority
            if not concert_name in self._whitelist:
                rospy.loginfo("App Manager: refusing an invitation as we are using a whitelist and '%s' is not whitelisted."%concert_name)
                return False
        else:
            if self._blacklist:
                if concert_name in self._blacklist:
                    rospy.loginfo("App Manager: refusing an invitation as '%s' is blacklisted."%concert_name)
                    return False

        ######################
        # Discovery
        ######################
        concerts = discover_concerts()
        concert_master = None
        for concert in concerts:
            if concert.name == concert_name:
                # Do we need to debug this further (i.e. check its resolved?)
                rospy.logdebug("App Manager: found the concert")
                concert_master = concert
                break
    
        if concert_master is None:
            rospy.logwarn("App Manager: invitation was from an undiscovered concert [%s]"%concert_name)
            return False
        # ros masters are currently hooked into ipv4 only.
        if len(concert_master.ipv4_addresses) > 0:
            concert_address = concert_master.ipv4_addresses[0]
        else:
            rospy.logwarn("App Manager: invitation was from an unresolvable concert [%s]"%concert_name)
            return False

        try:
            self.robot_namespace = self._unique_names[concert_name];
        except KeyError:
            rospy.loginfo("App Manager: received invitation from %s, but haven't yet received a unique namespace to use"%concert_name)
        if self._receive_invitation_callback(concert_address, concert_master.port, self.robot_namespace):
            self.concert_master = concert_master
            return True
        else:
            return False
